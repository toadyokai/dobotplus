"use strict";(self.webpackChunk_dobot_plus_website=self.webpackChunk_dobot_plus_website||[]).push([[2060],{89576:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>c});var n=r(65723),i=r(43327);const d={},t="Modbus",l={id:"lua/modbus",title:"Modbus",description:"Modbus is a communication protocol widely used for connecting industrial electronic devices. The following instructions outline the primary functions available for establishing communication between a Modbus master and slave devices, along with details on how to read from and write to various types of Modbus registers.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/lua/04-modbus.md",sourceDirName:"lua",slug:"/lua/modbus",permalink:"/dobotplus/en/lua/modbus",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"lua",previous:{title:"Logic",permalink:"/dobotplus/en/lua/flow"},next:{title:"TCP/UDP",permalink:"/dobotplus/en/lua/tcp"}},o={},c=[{value:"Instruction List",id:"instruction-list",level:2},{value:"<code>ModbusCreate</code>",id:"modbuscreate",level:2},{value:"Prototype",id:"prototype",level:3},{value:"Description",id:"description",level:3},{value:"Required Parameters",id:"required-parameters",level:3},{value:"Optional Parameters",id:"optional-parameters",level:3},{value:"Return Values",id:"return-values",level:3},{value:"Example",id:"example",level:3},{value:"<code>ModbusRTUCreate</code>",id:"modbusrtucreate",level:2},{value:"Prototype",id:"prototype-1",level:3},{value:"Description",id:"description-1",level:3},{value:"Required Parameters",id:"required-parameters-1",level:3},{value:"Optional Parameters",id:"optional-parameters-1",level:3},{value:"Return Values",id:"return-values-1",level:3},{value:"Example",id:"example-1",level:3},{value:"<code>ModbusClose</code>",id:"modbusclose",level:2},{value:"Prototype",id:"prototype-2",level:3},{value:"Description",id:"description-2",level:3},{value:"Required Parameters",id:"required-parameters-2",level:3},{value:"Return Values",id:"return-values-2",level:3},{value:"Example",id:"example-2",level:3},{value:"<code>GetInBits</code>",id:"getinbits",level:2},{value:"Prototype",id:"prototype-3",level:3},{value:"Description",id:"description-3",level:3},{value:"Required Parameters",id:"required-parameters-3",level:3},{value:"Return Values",id:"return-values-3",level:3},{value:"Example",id:"example-3",level:3},{value:"<code>GetInRegs</code>",id:"getinregs",level:2},{value:"Prototype",id:"prototype-4",level:3},{value:"Description",id:"description-4",level:3},{value:"Required Parameters",id:"required-parameters-4",level:3},{value:"Optional Parameters",id:"optional-parameters-2",level:3},{value:"Return Values",id:"return-values-4",level:3},{value:"Example",id:"example-4",level:3},{value:"<code>GetCoils</code>",id:"getcoils",level:2},{value:"Prototype",id:"prototype-5",level:3},{value:"Description",id:"description-5",level:3},{value:"Required Parameters",id:"required-parameters-5",level:3},{value:"Return Values",id:"return-values-5",level:3},{value:"Example",id:"example-5",level:3},{value:"<code>SetCoils</code>",id:"setcoils",level:2},{value:"Prototype",id:"prototype-6",level:3},{value:"Description",id:"description-6",level:3},{value:"Required Parameters",id:"required-parameters-6",level:3},{value:"Example",id:"example-6",level:3},{value:"<code>GetHoldRegs</code>",id:"getholdregs",level:2},{value:"Prototype",id:"prototype-7",level:3},{value:"Description",id:"description-7",level:3},{value:"Required Parameters",id:"required-parameters-7",level:3},{value:"Optional Parameters",id:"optional-parameters-3",level:3},{value:"Return Values",id:"return-values-6",level:3},{value:"Example",id:"example-7",level:3},{value:"<code>SetHoldRegs</code>",id:"setholdregs",level:2},{value:"Prototype",id:"prototype-8",level:3},{value:"Description",id:"description-8",level:3},{value:"Required Parameters",id:"required-parameters-8",level:3},{value:"Example",id:"example-8",level:3}];function a(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"modbus",children:"Modbus"})}),"\n",(0,n.jsx)(s.p,{children:"Modbus is a communication protocol widely used for connecting industrial electronic devices. The following instructions outline the primary functions available for establishing communication between a Modbus master and slave devices, along with details on how to read from and write to various types of Modbus registers."}),"\n",(0,n.jsx)(s.h2,{id:"instruction-list",children:"Instruction List"}),"\n",(0,n.jsx)(s.p,{children:"The following table provides an overview of Modbus functions used for communication:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Command"}),(0,n.jsx)(s.th,{children:"Function"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"ModbusCreate"})}),(0,n.jsx)(s.td,{children:"Create a Modbus master and establish a connection with a slave."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"ModbusRTUCreate"})}),(0,n.jsx)(s.td,{children:"Create a Modbus master based on RS485 interface."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"ModbusClose"})}),(0,n.jsx)(s.td,{children:"Disconnect from the Modbus slave."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"GetInBits"})}),(0,n.jsx)(s.td,{children:"Read contact registers."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"GetInRegs"})}),(0,n.jsx)(s.td,{children:"Read input registers."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"GetCoils"})}),(0,n.jsx)(s.td,{children:"Read coil registers."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"SetCoils"})}),(0,n.jsx)(s.td,{children:"Write to coil registers."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"GetHoldRegs"})}),(0,n.jsx)(s.td,{children:"Read holding registers."})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"SetHoldRegs"})}),(0,n.jsx)(s.td,{children:"Write to holding registers."})]})]})]}),"\n",(0,n.jsx)(s.p,{children:"The Modbus function codes for various register types are as follows:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Register Type"}),(0,n.jsx)(s.th,{children:"Read Register"}),(0,n.jsx)(s.th,{children:"Write Single Register"}),(0,n.jsx)(s.th,{children:"Write Multiple Registers"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Coil Register"}),(0,n.jsx)(s.td,{children:"01"}),(0,n.jsx)(s.td,{children:"05"}),(0,n.jsx)(s.td,{children:"0F"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Contact Register"}),(0,n.jsx)(s.td,{children:"02"}),(0,n.jsx)(s.td,{children:"-"}),(0,n.jsx)(s.td,{children:"-"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Input Register"}),(0,n.jsx)(s.td,{children:"04"}),(0,n.jsx)(s.td,{children:"-"}),(0,n.jsx)(s.td,{children:"-"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Holding Register"}),(0,n.jsx)(s.td,{children:"03"}),(0,n.jsx)(s.td,{children:"06"}),(0,n.jsx)(s.td,{children:"10"})]})]})]}),"\n",(0,n.jsx)(s.h2,{id:"modbuscreate",children:(0,n.jsx)(s.code,{children:"ModbusCreate"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"ModbusCreate(IP, port, slave_id, isRTU)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"This function creates a Modbus master and establishes a connection with a slave device. It supports a maximum of 15 simultaneous connections."}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["For built-in slave devices, set ",(0,n.jsx)(s.code,{children:"IP"})," to the robot's IP (default is ",(0,n.jsx)(s.code,{children:"192.168.5.1"}),", which can be modified) and the port to ",(0,n.jsx)(s.code,{children:"502"})," (map1) or ",(0,n.jsx)(s.code,{children:"1502"})," (map2). Refer to the Modbus register definition appendix for details."]}),"\n",(0,n.jsxs)(s.li,{children:["For third-party slave devices, set ",(0,n.jsx)(s.code,{children:"IP"})," and port to the respective addresses."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"IP"}),": Slave device's IP address."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"port"}),": Slave device's port."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"optional-parameters",children:"Optional Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"slave_id"}),": Slave ID."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"isRTU"}),": Boolean value. If omitted or set to ",(0,n.jsx)(s.code,{children:"false"}),", it establishes a Modbus TCP connection; if ",(0,n.jsx)(s.code,{children:"true"}),", it establishes a Modbus RTU connection."]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Note"}),": This parameter determines the protocol format for data transmission after the connection is established and does not affect the connection result. If set incorrectly, the connection may succeed, but subsequent communications may fail."]}),"\n",(0,n.jsx)(s.h3,{id:"return-values",children:"Return Values"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"err"}),":"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": Successfully created the Modbus master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"1"}),": The maximum number of Modbus masters has been reached; creation failed."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"2"}),": Initialization of the master failed (check IP, port, network, etc.)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"3"}),": Connection to the slave failed (check if the slave is operational and if the network is functional)."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Returns the index of the created master for subsequent Modbus function calls. Range: ",(0,n.jsx)(s.code,{children:"[0, 14]"})]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"example",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:'-- Create Modbus master and connect to specified slave.\nlocal ip = "192.168.5.123" \nlocal port = 503 \nlocal err = 0\nlocal id = 0\nerr, id = ModbusCreate(ip, port, 1)\n\n-- Create Modbus master and connect to built-in slave.\nlocal ip = "192.168.5.1" \nlocal port = 502\nerr, id = ModbusCreate(ip, port)\n'})}),"\n",(0,n.jsx)(s.h2,{id:"modbusrtucreate",children:(0,n.jsx)(s.code,{children:"ModbusRTUCreate"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-1",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"ModbusRTUCreate(slave_id, baud, parity, data_bit, stop_bit)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-1",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Creates a Modbus master based on RS485 interface and establishes a connection with a slave device. It supports a maximum of 15 simultaneous connections."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-1",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"slave_id"}),": Slave ID."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"baud"}),": Baud rate for the RS485 interface."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"optional-parameters-1",children:"Optional Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"parity"}),": Parity bit. ",(0,n.jsx)(s.code,{children:'"O"'})," for odd, ",(0,n.jsx)(s.code,{children:'"E"'})," for even, ",(0,n.jsx)(s.code,{children:'"N"'})," for none. Default is ",(0,n.jsx)(s.code,{children:'"E"'})," if not provided."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"data_bit"}),": Data bit length. Default value is ",(0,n.jsx)(s.code,{children:"8"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"stopbit"}),": Stop bit length. Options are ",(0,n.jsx)(s.code,{children:"1"})," or ",(0,n.jsx)(s.code,{children:"2"}),". Default value is ",(0,n.jsx)(s.code,{children:"1"}),"."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"return-values-1",children:"Return Values"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"err"}),":","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": Successfully created the Modbus master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"1"}),": Failed to create the Modbus master."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Returns the index of the created master for subsequent Modbus function calls."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"example-1",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"-- Create Modbus master and connect to RS485 slave with ID 1 and baud rate of 115200.\nerr, id = ModbusRTUCreate(1, 115200)\n"})}),"\n",(0,n.jsx)(s.h2,{id:"modbusclose",children:(0,n.jsx)(s.code,{children:"ModbusClose"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-2",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"ModbusClose(id)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-2",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Disconnects from the Modbus slave and releases the master."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-2",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"return-values-2",children:"Return Values"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Operation result:","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"0"}),": Successfully disconnected."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"1"}),": Failed to disconnect."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"example-2",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"-- Disconnect from the Modbus slave.\nModbusClose(id)\n"})}),"\n",(0,n.jsx)(s.h2,{id:"getinbits",children:(0,n.jsx)(s.code,{children:"GetInBits"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-3",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"GetInBits(id, addr, count)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-3",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Reads the values from the Modbus slave's contact register address. Corresponds to Modbus function code 02."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-3",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"addr"}),": Starting address of the contact register."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"count"}),": Number of continuous contact registers to read (1-2000, depending on the slave's register count and protocol specifications)."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"return-values-3",children:"Return Values"}),"\n",(0,n.jsx)(s.p,{children:"Returns the values from the contact register address stored in a table. The first value corresponds to the value of the starting address."}),"\n",(0,n.jsx)(s.h3,{id:"example-3",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"-- Read 5 continuous values starting from address 0.\ninBits = GetInBits(id, 0, 5)\n"})}),"\n",(0,n.jsx)(s.h2,{id:"getinregs",children:(0,n.jsx)(s.code,{children:"GetInRegs"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-4",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"GetInRegs(id, addr, count, type)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-4",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Reads the values from the Modbus slave's input register address based on the specified data type. Corresponds to Modbus function code 04."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-4",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"addr"}),": Starting address of the input register."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"count"}),": Number of continuous input registers to read (1-125, depending on the slave's register count and protocol specifications)."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"optional-parameters-2",children:"Optional Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"type"}),": Data type (default is ",(0,n.jsx)(s.code,{children:"U16"})," if omitted).","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"U16"}),": 16-bit unsigned integer (2 bytes, occupying 1 register)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"U32"}),": 32-bit unsigned integer (4 bytes, occupying 2 registers)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"F32"}),": 32-bit single-precision float (4 bytes, occupying 2 registers)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"F64"}),": 64-bit double-precision float (8 bytes, occupying 4 registers)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"return-values-4",children:"Return Values"}),"\n",(0,n.jsx)(s.p,{children:"Returns the values from the input register address stored in a table. The first value corresponds to the starting address."}),"\n",(0,n.jsx)(s.h3,{id:"example-4",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:'-- Read a 32-bit unsigned integer starting from address 2048.\ndata = GetInRegs(id, 2048, 2, "U32")\n'})}),"\n",(0,n.jsx)(s.h2,{id:"getcoils",children:(0,n.jsx)(s.code,{children:"GetCoils"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-5",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"GetCoils(id, addr, count)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-5",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Reads the values from the Modbus slave's coil register address. Corresponds to Modbus function code 01."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-5",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"addr"}),": Starting address of the coil register."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"count"}),": Number of continuous coil registers to read (1-2000, depending on the slave's register count and protocol specifications)."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"return-values-5",children:"Return Values"}),"\n",(0,n.jsx)(s.p,{children:"Returns the values from the coil register address stored in a table. The first value corresponds to the starting address."}),"\n",(0,n.jsx)(s.h3,{id:"example-5",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"-- Read 5 continuous values starting from address 0.\nCoils = GetCoils(id, 0, 5)\n"})}),"\n",(0,n.jsx)(s.h2,{id:"setcoils",children:(0,n.jsx)(s.code,{children:"SetCoils"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-6",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"SetCoils(id, addr, count, table)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-6",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Writes specified values to the coil registers at the specified addresses. Corresponds to Modbus function codes 05 (write single) and 0F (write multiple)."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-6",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"addr"}),": Starting address of the coil register."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"count"}),": Number of continuous coil registers to write (1-1968, depending on the slave's register count and protocol specifications)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"table"}),": Values to be written to the coil registers stored in a table. The first value corresponds to the starting address."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"example-6",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"-- Write continuous values to 5 coils starting from address 1024.\nlocal Coils = {0, 1, 1, 1, 0}\nSetCoils(id, 1024, #Coils, Coils)\n"})}),"\n",(0,n.jsx)(s.h2,{id:"getholdregs",children:(0,n.jsx)(s.code,{children:"GetHoldRegs"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-7",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"GetHoldRegs(id, addr, count, type)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-7",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Reads the values from the Modbus slave's holding register"}),"\n",(0,n.jsx)(s.p,{children:"address based on the specified data type. Corresponds to Modbus function code 03."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-7",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"addr"}),": Starting address of the holding register."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"count"}),": Number of continuous holding registers to read (1-125, depending on the slave's register count and protocol specifications)."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"optional-parameters-3",children:"Optional Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"type"}),": Data type (default is ",(0,n.jsx)(s.code,{children:"U16"})," if omitted).","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"U16"}),": 16-bit unsigned integer (2 bytes, occupying 1 register)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"U32"}),": 32-bit unsigned integer (4 bytes, occupying 2 registers)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"F32"}),": 32-bit single-precision float (4 bytes, occupying 2 registers)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"F64"}),": 64-bit double-precision float (8 bytes, occupying 4 registers)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"return-values-6",children:"Return Values"}),"\n",(0,n.jsx)(s.p,{children:"Returns the values from the holding register address stored in a table. The first value corresponds to the starting address."}),"\n",(0,n.jsx)(s.h3,{id:"example-7",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:'-- Read a 32-bit unsigned integer starting from address 2048.\nholdRegData = GetHoldRegs(id, 2048, 2, "U32")\n'})}),"\n",(0,n.jsx)(s.h2,{id:"setholdregs",children:(0,n.jsx)(s.code,{children:"SetHoldRegs"})}),"\n",(0,n.jsx)(s.h3,{id:"prototype-8",children:"Prototype"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"SetHoldRegs(id, addr, count, table)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"description-8",children:"Description"}),"\n",(0,n.jsx)(s.p,{children:"Writes specified values to the holding registers at the specified addresses. Corresponds to Modbus function codes 06 (write single) and 10 (write multiple)."}),"\n",(0,n.jsx)(s.h3,{id:"required-parameters-8",children:"Required Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"id"}),": Index of the created master."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"addr"}),": Starting address of the holding register."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"count"}),": Number of continuous holding registers to write (1-123, depending on the slave's register count and protocol specifications)."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"table"}),": Values to be written to the holding registers stored in a table. The first value corresponds to the starting address."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"example-8",children:"Example"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-lua",children:"-- Write continuous values to 5 holding registers starting from address 2048.\nlocal holdRegs = {100, 200, 300, 400, 500}\nSetHoldRegs(id, 2048, #holdRegs, holdRegs)\n"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},43327:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>l});var n=r(22155);const i={},d=n.createContext(i);function t(e){const s=n.useContext(d);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),n.createElement(d.Provider,{value:s},e.children)}}}]);